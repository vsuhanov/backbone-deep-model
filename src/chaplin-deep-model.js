// Generated by CoffeeScript 1.6.3
(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  define(['underscore', 'chaplin'], function(_, Chaplin) {
    var DeepModel, deleteNested, getNested, objToPaths, setNested;
    objToPaths = function(obj) {
      var key, key2, obj2, ret, separator, val, val2;
      ret = {};
      separator = DeepModel.keyPathSeparator;
      for (key in obj) {
        val = obj[key];
        if (val && val.constructor === Object && !_.isEmpty(val)) {
          obj2 = objToPaths(val);
          for (key2 in obj2) {
            val2 = obj2[key2];
            ret[key + separator + key2] = val2;
          }
        } else {
          ret[key] = val;
        }
      }
      return ret;
    };
    getNested = function(obj, path, return_exists) {
      var fields, i, n, result, separator, _i;
      separator = DeepModel.keyPathSeparator;
      fields = path.split(separator);
      result = obj;
      return_exists || (return_exists === false);
      n = fields.length;
      for (i = _i = 0; 0 <= n ? _i < n : _i > n; i = 0 <= n ? ++_i : --_i) {
        if (return_exists && !_.has(result, fields[i])) {
          return false;
        }
        result = result[fields[i]];
        if (result === null && i < n - 1) {
          result = {};
        }
        if (typeof result === 'undefined') {
          if (return_exists) {
            return true;
          }
          return result;
        }
      }
      if (return_exists) {
        return true;
      }
      return result;
    };
    setNested = function(obj, path, val, options) {
      var field, fields, i, n, result, separator, _i, _results;
      options = options || {};
      separator = DeepModel.keyPathSeparator;
      fields = path.split(separator);
      result = obj;
      n = fields.length;
      _results = [];
      for (i = _i = 0; 0 <= n ? _i < n : _i > n; i = 0 <= n ? ++_i : --_i) {
        if (result === void 0) {
          break;
        }
        field = fields[i];
        if (i === n - 1) {
          if (options.unset) {
            _results.push(delete result[field]);
          } else {
            _results.push(result[field] = val);
          }
        } else {
          if (typeof result[field] === 'undefined' || !_.isObject(result[field])) {
            result[field] = {};
          }
          _results.push(result = result[field]);
        }
      }
      return _results;
    };
    deleteNested = function(obj, path) {
      return setNested(obj, path, null, {
        unset: true
      });
    };
    DeepModel = (function(_super) {
      __extends(DeepModel, _super);

      function DeepModel(attributes, options) {
        var attrs, defaults;
        attrs = attributes || {};
        this.cid = _.uniqueId('c');
        this.attributes = {};
        if (options && options.collection) {
          this.collection = options.collection;
        }
        if (options && options.parse) {
          attrs = this.parse(attrs, options || {});
        }
        if (defaults = _.result(this, 'defaults')) {
          attrs = _.deepExtend({}, defaults, attrs);
        }
        this.set(attrs, options);
        this.changed = {};
        this.initialize.apply(this, arguments);
      }

      DeepModel.prototype.toJSON = function(options) {
        return _.deepClone(this.attributes);
      };

      DeepModel.prototype.get = function(attr) {
        return getNested(this.attributes, attr);
      };

      DeepModel.prototype.set = function(key, val, options) {
        var alreadyTriggered, attr, attrs, changes, changing, current, fields, i, n, parentKey, prev, separator, silent, unset, wildcardKey, _i, _j, _ref, _ref1;
        if (key === null) {
          return this;
        }
        if (typeof key === 'object') {
          attrs = key;
          options = val || {};
        } else {
          (attrs = {})[key] = val;
        }
        options || (options = {});
        if (!this._validate(attrs, options)) {
          return false;
        }
        unset = options.unset;
        silent = options.silent;
        changes = [];
        changing = this._changing;
        this._changing = true;
        if (!changing) {
          this._previousAttributes = _.deepClone(this.attributes);
          this.changed = {};
        }
        current = this.attributes;
        prev = this._previousAttributes;
        if (this.idAttribute in attrs) {
          this.id = attrs[this.idAttribute];
        }
        attrs = objToPaths(attrs);
        for (attr in attrs) {
          val = attrs[attr];
          if (!_.isEqual(getNested(current, attr), val)) {
            changes.push(attr);
          }
          if (!_.isEqual(getNested(prev, attr), val)) {
            setNested(this.changed, attr, val);
          } else {
            deleteNested(this.changed, attr);
          }
          if (unset) {
            deleteNested(current, attr);
          } else {
            setNested(current, attr, val);
          }
        }
        if (!silent) {
          if (changes.length) {
            this._pending = true;
          }
          separator = DeepModel.keyPathSeparator;
          alreadyTriggered = {};
          for (i = _i = 0, _ref = changes.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
            key = changes[i];
            if (!alreadyTriggered.hasOwnProperty(key) || !alreadyTriggered[key]) {
              alreadyTriggered[key] = true;
              this.trigger('change:' + key, this, getNested(current, key), options);
            }
            fields = key.split(separator);
            for (n = _j = _ref1 = fields.length - 1; _ref1 <= 0 ? _j < 0 : _j > 0; n = _ref1 <= 0 ? ++_j : --_j) {
              parentKey = _.first(fields, n).join(separator);
              wildcardKey = parentKey + separator + '*';
              if (!alreadyTriggered.hasOwnProperty(wildcardKey) || !alreadyTriggered[wildcardKey]) {
                alreadyTriggered[wildcardKey] = true;
                this.trigger('change:' + wildcardKey, this, getNested(current, parentKey), options);
              }
              if (!alreadyTriggered.hasOwnProperty(parentKey) || !alreadyTriggered[parentKey]) {
                alreadyTriggered[parentKey] = true;
                this.trigger('change:' + parentKey, this, getNested(current, parentKey), options);
              }
            }
          }
        }
        if (changing) {
          return this;
        }
        if (!silent) {
          while (this._pending) {
            this._pending = false;
            this.trigger('change', this, options);
          }
        }
        this._pending = false;
        this._changing = false;
        return this;
      };

      DeepModel.prototype.clear = function(options) {
        var attrs, key, shallowAttributes, _i, _len;
        attrs = {};
        shallowAttributes = objToPaths(this.attributes);
        for (_i = 0, _len = shallowAttributes.length; _i < _len; _i++) {
          key = shallowAttributes[_i];
          attrs[key] = void 0;
        }
        return this.set(attrs, _.extend({}, options, {
          unset: true
        }));
      };

      DeepModel.prototype.hasChanged = function(attr) {
        if (attr == null) {
          return !_.isEmpty(this.changed);
        }
        return getNested(this.changed, attr) !== void 0;
      };

      DeepModel.prototype.changedAttributes = function(diff) {
        var attr, changed, old, val;
        if (!diff) {
          return (this.hasChanged() ? objToPaths(this.changed) : false);
        }
        old = this._changing ? this._previousAttributes : this.attributes;
        diff = objToPaths(diff);
        old = objToPaths(old);
        val = changed = false;
        for (attr in diff) {
          if (_.isEqual(old[attr], (val = diff[attr]))) {
            continue;
          }
          (changed || (changed = {}))[attr] = val;
        }
        return changed;
      };

      DeepModel.prototype.previous = function(attr) {
        if (attr === null || !this._previousAttributes) {
          return null;
        }
        return getNested(this._previousAttributes, attr);
      };

      DeepModel.prototype.previousAttributes = function() {
        return _.deepClone(this._previousAttributes);
      };

      return DeepModel;

    })(Chaplin.Model);
    DeepModel.keyPathSeparator = '.';
    Chaplin.DeepModel = DeepModel;
    if (typeof module !== void 0) {
      module.exports = DeepModel;
    }
    return Chaplin;
  });

}).call(this);
